# 2. 模块化

### JavaScript杂谈

#### 开始之前

这应该是我第三篇JS杂谈了，我逐渐意识到模块化对神岛目前的地图改变非常大，很多问题都能迎刃而解，以至于我们能轻松编写简短而优雅的代码\
有时候对优雅的追求也能为你节省时间，谁都不愿意将大把的时间放在一些玄学问题上是吧

所以，我就写了这篇教程，或者说短文，为的就是让更多人能理解模块化

再次提醒！这篇教程属于JavaScript杂谈系列，内容上会少很多基础内容，如果你没有前置基础知识，简易先去补补

如果你有什么要补充的问题或者希望能够详细解答的，欢迎加入Nomen小队！

> 提示：本文由Nomen编写，由于Nomen是个_**萌新**_，所以**本文可能存在错漏，欢迎大家指出并且纠正！**

## 第二期 - 模块化

***

#### 目录

1. 核心概念
   1. 模块化
   2. 封装
   3. 接口
   4. 重用
   5. 可维护性
2. 模块化理论
   1. 模块划分
   2. 模块设计
   3. 模块组合
3. 小结

***

### 核心概念

#### 1. 模块化

如何介绍模块化？我觉得可能很好解释

现在，你是一个公司的老板，你有三个部门：财政、人事和某个生产部\
那么现在，我们都清楚 这三个部门能做的事情，不能做的事情\
财政部很显然不能管理人事问题，生产部很显然不能管理财政问题\
**这展示了一个模块化核心概念：大系统分解为多个独立、可管理的小的部门（模块）**

很显然，相较于用一个极端庞大的系统处理所有问题，使用互相内聚、互相沟通并且独立职责的小模块能更好地处理复杂问题\
三个部门之间只负责自己的职责，你只需要在执行命令的时候，在正确的时间使用正确的部门做正确的事情，而不需要通过一个离谱的臃肿的部门进行全部的任务

例如，如果你想要调查应不应该_优化_这个程序员，你只需要问一下各个部门的情况，然后最终做出决定，你不需要为此写上一整个流程，让每个操作都复制一份全部部门

总而言之，模块化原则能够确保大系统被分解为小模块，这些小模块专注于解决特定问题（生产部不会去帮财政部算账单），并且最终通过调用这些模块来组合成特定复杂的操作

#### 2. 封装

回到上个上下文，思考，生产部需要知道人事部是如何进行招聘吗？人事部需要知道生产部编写了哪些代码来让招聘变轻松吗？很显然不，知道这些细节对生产部能不能写出更多代码起不了什么作用\
但是，人事部提供了一个群聊，你能在里面得知是否有足够的人手来为生产部编写代码\
生产部没有直接对人事部招人现状进行统计，而是通过人事部特定的**接口**来完成逻辑\
**这展示了另一个模块化核心概念：封装内部细节，只暴露必要的接口**

为什么封装内部细节？那是为了**防止意外的不必要的修改，隐藏内部状态和执行细节**。如果生产部选择直接获取人事部电脑上的招聘详情的资料，从而暴露了很多人的个人信息或者不小心把这个重要文件ctrl+x了，会发生什么？\
生产部肯本不需要知道这些新来的不知道哪个部门的人的个人信息，也无意去删掉他们的文件，但是一个很简单的事情引来了一场灾难：对象内部状态被意外篡改，内部信息暴露在外部，人事部怎么CPU新员工的手法全部被人知道了（等等怎么感觉有些奇怪）

对于你来讲，你是觉得问那个群聊一句话更方便 还是去搞一份资料分析一遍最后再来一句：“等等，在人事部电脑上我点的是ctrl+c还是ctrl+x？”

再聊聊封装的好处\
一个对象只有一些你很显然清楚用来干啥的方法，例如getHowManyDaysOfVacationThisMonth（这个又臭又长的名字就别用了，改名应该叫getVacationNumber），还是去运算一遍company.vacation.length（最终结果为0）\
很显然，你会选择前者，我们根本不需要知道到底是如何计算假期天数的，调用这个接口就能得到我想要的结果，奥太棒了！

（人类明明知道这么做能得到好处，却依旧会寻找背后原因，我希望你不要把这份精神用在代码设计上）

总而言之，我们在进行设计的时候，对单位贯彻封装原则：隐藏内部实现，保护内部状态，仅暴露可管理的方便的接口

#### 3. 接口

想必在上面的文章中，你多从听到了接口这两个字\
什么是接口？\
接口，就是其他人轻松调用就能实现逻辑的东西，他们不需要知道你怎么实现，只知道调用你的接口，事情就会完美解决

讲个实际的例子吧，如果你要编写一个玩家金币系统，你会选择哪个？

```javascript
// 1. 忍者风代码

player.coin = 0;

whenSomethingHappen(()=> {
    player.coin += 1; // 或者某些我们不知道的愚蠢的用户输入
});

// 2. 接口

player._coin = 0;
player.coin = {
    get(){
        return player._coin;
    },
    set(num){
        if(isNaN(num)) throw new Error("❤️不要往里面塞一些奇奇怪怪的东西啊❤️")
        player._coin = num;
    }
}

whenSomethingHappen(()=> {
    try {
        player.coin.set(1);
    } catch {
        alert("请输入一个正确的数字");
    }
});
```

很显然，通过接口，我们能够很好的控制输入，管理行为和对行为进行追踪，如果上面的例子中用户输入了个愚蠢的东西，例如"undefined"，那么你的player.coin就会变成NaN

而回到公司模型，公司部门之间通过最简单的接口，可以为对方提供数据或进行操作，而这些操作都是由统一协议规定的，而无需直接操作对方部门的数据

_感谢冒险岛项目给予我惨痛的一课，因为我的玩家的金币数量最终变成了null、undefined、NaN或者一个巨大的数字（因为字符串拼接）_

总结，通过统一接口，我们能够管理我们的代码行为以及阻止意外的操作

#### 4. 重用

我觉得我们不需要讲太多有关重用的内容，一个例子比较一切

```javascript
// 1. 忍者风代码

let attk1 = player1.atk + xxx - xxx * xxx / xxx; // 某些很复杂的操作
let attk2 = player2.atk + xxx - xxx * xxx / xxx;
let attk3 = attk1 - attk2;

// 2. 可重用模块

const {calAtk} = (function(){
    return {
        calAtk: (player)=>player.atk + xxx - xxx * xxx / xxx
    };
})();


// 模块1中
let attk3 = calAtk(player1) - calAtk(player2);

// 模块2中
let attk4 = calAtk(player3) - calAtk(player4);
```

大家就会发现，当模块封装为一组方法，我们能轻松重用这些代码，而不需要编写很多又臭又长的重复代码，最重要的一点在于，这个模块可以**在多个模块之间重复使用**，但是访问的是同一个上下文，并且没有其他过多的依赖

#### 5. 可维护性

这一点我们先前便已有例子展示了，模块化可以让操作和接口变得可控，每个模块都能独立地进行**修改和测试**

当一个模块出问题，我们能够通过其行为，输入和输出来推断问题所在，如果是一整个大系统，那么我们恐怕就要检查整个系统来确定问题所在

***

### 模块化理论

接下来的内容可能会有些超纲，如果你对模块化很感兴趣，可以继续阅读（前提是你为这个仓库贡献了star！

来仓库看看吧！https://github.com/helloyork/york-javascript-tutorials

模块设计可以被简单的理解为三步：

1. 模块划分
2. 模块设计
3. 模块组合

整体上，这些步骤，从宏观到微观，再从微观再到宏观，完成了大部分的模块设计

#### 1. 模块划分

简单来讲，模块应该以其作用/目的出发，确保每个模块都能专注于特定问题而无需大量的互相依赖

例如，当我们设计一个游戏业务时，模块可以划分为以下几块:

> 用户数据模块
>
> > 可以细分为账户信息和数据储存
>
> 游戏逻辑模块
>
> > 可以细分为：游戏引擎逻辑、游戏规则、角色行为、AI等
>
> 玩家交互/操作模块

那么这些模块之间互相通信，互相传递最少的信息来完成最多的交流，这必须要考验代码的聚合能力了，减少耦合来为模块提供更高的自由度（详见下方模块设计）

我们可以清晰地观察到，每一个模块都专注于当前的问题，用户数据模块只负责增删改查用户数据，而不会直接触碰游戏引擎，游戏引擎只需要调用用户数据API，就能完成查询，而无需在代码中发起对数据库的访问

而往专业方向来讲，我们需要对业务需求进行具体划分

1. 流程\
   如果业务逻辑更偏向流程类产品，例如一个购物网站，我们需要用户经过 _**<选择商品>-<付款>-<追踪商品状态>**_ 这一流程，而这个流程则是多个线性任务阶段所组成的，我们可以划分以下模块

> * 商品搜索模块 _**<选择商品>**_
> * 购物车模块
> * 支付模块 _**<付款>**_
> * 商品信息模块
> * 商品追踪模块 _**<追踪商品状态>**_（依赖于商品信息模块以完成查询）

而这些模块，每一个模块都对应了这个线性任务模型中的阶段

2. 内容载体 内容载体类产品和流程不一样，其不是以某一具体目标为主体，而是更注重内容信息的分类、排序、筛选\
   例如一个新闻网站，它主要是用于完成许多可能不存在关联的任务，主要以内容聚合为主的框架，那么它的模块可以划分为

> * 新闻查询模块
> * 新闻详细信息模块
> * 新闻管理模块
> * 新闻推送模块

他们互相之间不存在很强的流程关联，但是都属于一个新闻网站该有的逻辑，这些模块之间互相调用，互相管理，以完成更复杂的任务

这两种模块的划分都是为了更好地满足用户需求，提高用户的可用性和用户体验

#### 2. 模块设计

我们在遵顼模块化设计5个原则时，还要注意以下三个关键特性：

1. **复用性**：复用性是指模块能在多个场景中被重复使用。例如，一个用户登录模块可以在多个系统中复用，这样可以减少用户的学习成本，提高用户体验的一致性和延续性。同时，复用模块也可以提高产品设计的效率和产品的稳定性。
2. **延展性**：延展性是指模块能够适应不同的需求或业务差异。例如，一个新闻查询模块可以设计成可以查询不同类型的新闻，如国内新闻、国际新闻、体育新闻等，这样就具有了一定的延展性。
3. **互换性**：互换性是指当一个模块无法满足新的业务需求时，可以用另一个模块来替换。例如，如果一个新闻查询模块只能查询文本新闻，当需要查询视频新闻时，就可以用一个能查询视频新闻的模块来替换。

需要注意的是，为了遵循开发上的规范与降低日后维护的成本，模块应该始终保持其对外信息解构的统一，也就是说，如果你对其中一部分代码进行修改，或通过互换性替换了某个模块，那么你对外的使用方法和数据解构应该大体保持一致，以防止意外的错误和耦合

#### 3. 模块组合

这一部分没有什么要讲的内容，只是注意，始终遵循开发规范，不能修改封闭模块内的内部状态，做一个合格的调用者，始终保持模块之间的低耦合度与高内聚形态，你就可以编写出优秀的代码

### 小结

我们在这次的教程中着重讲解了模块设计原则与如何进行模块设计三步骤\
本文没有具体抛出实例来为大家讲解如何编写模块化代码、如何测试和维护模块、如何定义和使用模块接口以及模块化的实践与陷阱，这些都不属于本文的讨论范围之内，若以后有机会（有人催），我会在《给初学者看的JavaScript》中讲解这些内容（不要老是给自己挖坑啊喂）

非常感谢您的观看！我是Nomen，我们下次再见！

> 参考资料：\
> [Javascript模块化编程（一）：模块的写法](https://www.ruanyifeng.com/blog/2012/10/javascript\_module.html)\
> [JavaScript 模块化入门Ⅰ：理解模块](https://zhuanlan.zhihu.com/p/22890374)\
> [JavaScript 模块化入门Ⅱ：模块打包构建](https://zhuanlan.zhihu.com/p/22945985)\
> [【设计前沿】模块化设计](https://zhuanlan.zhihu.com/p/410015339)\
> [深入理解JavaScript 模块模式](https://www.oschina.net/translate/javascript-module-pattern-in-depth)\
> [开发者都应该了解的7种JavaScript设计模式](https://zhuanlan.zhihu.com/p/150656050)
